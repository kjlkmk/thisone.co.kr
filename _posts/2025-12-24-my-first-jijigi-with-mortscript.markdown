---
layout: post
title: "[나의 개발일지] 옴니아(Omnia)와 모트스크립트, 나의 첫 '지지기' 제작기"
date: 2025-12-24 11:00:00 +0900
categories: [업계이야기, 개발일지]
tags: [모트스크립트, 옴니아, 윈도우모바일, 지지기, 퀵서비스, MortScript, 개발, 자동화]
author: "퀵서비스 기사"
excerpt: "프로그램의 '프'자도 모르던 퀵기사가 '고도리'를 보고 충격받아, 옴니아 폰과 모트스크립트(MortScript)로 자신만의 지지기를 만들어냈던 시절의 기록. 순수한 노가다와 아이디어로 기술의 한계를 극복했던 과거의 유물을 추억합니다."
published: false
---

안녕하세요, 동료 기사님들. '도로 위를 달리는 퀵서비스 기사'입니다.

지난번 '[지지기 20년 비사]' 글에서 제가 직접 스크립트를 만들어 사용했던 시절을 잠시 언급했었는데요, 많은 분들이 그 시절의 이야기를 궁금해하시는 것 같아 오늘은 그 '과거의 유물'에 대한 이야기를 좀 더 자세히 풀어볼까 합니다.

이것은 패킷도, 멀티앱도 없던 시절, 삼성 '옴니아'라는 스마트폰과 '모트스크립트(MortScript)'라는 이름도 생소한 언어 하나만 가지고, 오로지 '노가다'와 아이디어로 저만의 지지기를 만들었던 눈물겨운(?) 개발 일지입니다.

### 모든 것의 시작: '고도리'와 나의 오기

때는 2010년대 초, 스마트폰이라고는 윈도우 모바일(Windows Mobile)이 탑재된 옴니아가 전부이던 시절이었습니다. 당시 기사들 사이에서는 가산디지털단지에서 설치해 주는 '고도리'라는 지지기가 선풍적인 인기를 끌었죠. 남들보다 편하게, 더 빨리 오더를 잡는 모습을 보며 부러움과 동시에 마음 한구석에서 오기가 생겼습니다.

> "저걸 내 손으로 직접 옴니아에서 구현해 볼 수는 없을까?"

프로그램의 '프'자도 몰랐던, 무모한 도전의 시작이었습니다.

### 한 줄기 빛: '대리운전 카페'와 모트스크립트

막막했던 저에게 한 줄기 빛이 되어준 곳은 의외로 '대리운전 기사 카페'였습니다. 그곳에서 윈도우 모바일용 자동화 스크립트 언어인 **'모트스크립트(MortScript)'**라는 존재를 처음 알게 되었죠.

그날부터 저의 밤샘 연구가 시작되었습니다. 메뉴얼을 한 줄 한 줄 읽고, `Sleep`, `MouseClick`, `ColorAt` 같은 명령어들을 메모장에 적어두고 밤새 테스트했습니다. "이걸 누르면 어떻게 될까?", "이 좌표의 색상 값은 뭘까?" 하나하나 직접 부딪혀가며 기능을 익혔습니다. 마치 어린아이가 처음 글자를 배우는 것 같았죠.

### 나의 첫 작품: 순수한 '원터치'의 시대

그 당시 옴니아의 퀵서비스 앱은 **'투터치' 방식**이었습니다. 메인 화면의 오더 리스트에서 원하는 오더를 손가락으로 한 번 터치하면 '상세 배차 화면'이 나타나고, 그 화면에서 '예' 또는 '아니오' 버튼 중 '예' 버튼을 다시 터치해야 비로소 배차가 확정되는 방식이었죠.

저의 진짜 첫 작품은, '달빛마트' 같은 곳에서 '원터치' 지지기가 있다는 소문을 듣고 "이 정도는 나도 만들 수 있겠다" 싶어 제작한 아주 단순한 스크립트였습니다.

이 스크립트는 거창한 기능 없이, 오직 '상세 배차 화면'이 나타났을 때 자동으로 '예' 버튼 하나만 눌러주는 기능이었습니다. 이른바 '투터치'를 '원터치'로 만들어주는 스크립트였죠.

```mortscript
// --- 나의 첫 '원터치' 지지기 (초기 버전) ---
Repeat(50000000) // 스크립트가 꺼지지 않게 무한 반복
    sleep(50) // CPU 과부하를 막기 위해 잠깐 대기

    // '상세 배차 화면' 창이 활성화되었는지 확인하고,
    If (WndActive("상세배차화면") = 1)
        sleep(20)
        // '예' 버튼 좌표를 그냥 클릭!
        MouseClick(175, 716) 
        // 배차 처리를 위해 3초간 대기
        sleep(3000) 
    EndIf
EndRepeat
```
정말 단순했지만, 운전 중에 '예' 버튼을 누르기 위해 폰을 다시 조작해야 하는 위험과 번거로움을 줄여준, 저에게는 아주 소중한 첫 작품이었습니다.

### '고도리'와의 만남: 진짜 도전의 시작

그렇게 저만의 '원터치' 스크립트에 만족하며 지내던 어느 날, 한 동료 기사가 가산동에 가서 안드로이드폰에 **'고도리'**를 설치해왔다며 자랑을 늘어놓았습니다.

> "이것 봐, 도착지랑 금액을 미리 설정해두면 알아서 잡아줘! 화면이 세 개로 나뉘어서 인성1, 인성2, 로지를 한 번에 볼 수도 있어!"

그 말을 듣는 순간 머리를 한 대 세게 맞은 듯한 충격을 받았습니다. 제 스크립트는 고작 버튼 하나 눌러주는 게 전부인데, 고도리는 **'자동 배차 설정'**이라는, 차원이 다른 기능을 가지고 있었던 겁니다. 남들은 눈으로 보고 오더를 고를 때, 고도리는 설정된 조건만 맞으면 기계가 알아서 오더를 잡아주니 경쟁 자체가 성립되지 않았습니다.

하지만 상용 지지기인 '고도리' 역시 완벽하지만은 않았습니다. 인성 앱이 업데이트될 때마다 '고도리'가 먹통이 되기 일쑤였고, 그때마다 기사들은 가산동까지 찾아가거나 개발사가 업데이트해주기를 마냥 기다려야 하는 불편함을 겪었습니다. 심지어 비싸게 준 안드로이드폰 대신 옴니아로 다시 갈아타는 동료도 있을 정도였죠. 이러한 불안정성은 저에게 '내 손으로 직접 만들자'는 더욱 강력한 동기를 부여했습니다.

그때부터 저의 진짜 도전이 시작되었습니다. "그래? 그럼 나도 옴니아에서 저 자동 배차 설정을 따라 만들어보자!"

### '고도리' 따라잡기: 노가다로 구현한 핵심 기능들

하지만 '고도리'의 기능을 따라 만드는 길은 험난했습니다. 함수나 반복문도 제대로 모르는 상태에서, 제가 아는 몇 안 되는 명령어로 모든 것을 해결해야 했으니까요.

#### 문제 1: 매번 미세하게 바뀌는 오더 목록의 Y좌표!

가장 큰 문제였습니다. 안드로이드 시대와 달리 옴니아용 윈도우 기반 앱은 업데이트가 없었기에 UI 자체가 바뀌는 일은 없었습니다. 하지만 오더 목록이 화면에 표시될 때마다 그 시작점의 Y좌표가 미세하게 달라지는 현상이 있었습니다. 이 때문에 고정된 좌표값만으로는 정확한 오더를 클릭할 수 없었죠.

이것을 해결하기 위해 오더 목록 상단에 항상 표시되는 **'구분선'**을 동적 기준점으로 삼는 아이디어를 냈습니다.

```mortscript
// --- 구분선 감지를 통한 Y좌표 보정 로직 ---
// 내가 생각하는 구분선의 기준 Y좌표 (예: 149)
inkijun_y = 149 

// 실제 화면에서 구분선(파란색 바)의 Y좌표를 찾는다.
For y = 140 To 160 step 1
    color_y = ColorAt(240, y) // 화면 중간 X좌표에서 Y축으로 스캔
    If (color_y = 6512995) // 파란색 구분선의 색상 코드
        // 기준 Y좌표와의 차이(오차)를 계산한다.
        y_offset = inkijun_y - y 
        Break // 찾았으면 반복 중단
    EndIf
Next

// 모든 클릭 대상의 Y좌표에 이 오차(y_offset)를 더해서 클릭한다.
// 이렇게 하면 리스트가 조금 위나 아래에 표시되어도 정확한 오더를 클릭할 수 있다.
MouseClick(x_coord, (original_y + y_offset))
```
이렇게 스크립트가 실행될 때마다 '구분선'의 실제 위치를 찾아내고, 그것을 기준으로 모든 타겟의 Y좌표를 다시 계산해주니 클릭 정확도가 비약적으로 상승했습니다.

#### 문제 2: 메인 화면의 금액을 읽을 수가 없다!

두 번째 난관은 오더 리스트 화면에서 '금액'을 인식하는 것이었습니다. `WindowText` 같은 명령어로 글자를 읽을 수 있는 건 상세 배차 화면뿐이었고, 리스트 화면의 숫자는 그림이나 다름없었죠.

여기서 또 저의 '노가다'가 빛을 발했습니다.

> "글자를 못 읽으면, 점으로 찍어서 모양을 인식하면 되지 않을까?"

예를 들어 숫자 '2'와 '3'은 윗부분과 아랫부분의 픽셀 패턴이 다릅니다. 저는 그 미세한 차이를 `ColorAt`으로 잡아냈습니다. 숫자 '2'를 인식하기 위해 특정 좌표 6개의 픽셀 색상 값을 동시에 확인하는 식이었죠.

```mortscript
// --- 숫자 '2' 인식 로직 (in0man2) ---
// 숫자 '2' 모양을 구성하는 핵심 픽셀 6개의 좌표와 색상값을 확인
ina2=ColorAt((398+xxx),(168+iny-ch))
inb2=ColorAt((400+xxx),(178+iny-ch))
...
inf2=ColorAt((397+xxx),(194+iny-ch))

// 6개 조건이 모두 맞으면 'man2' 변수를 참(True)으로 설정
man2 = ( (ina2 = 0) AND (inb2 = 16777215) AND ... )
```
이런 방식으로 2, 3, 4만 원대 오더를 구분하는 데 성공했고, 마침내 **'금액 필터링'**이라는 핵심 기능을 완성할 수 있었습니다.

### 진화: 나만의 툴에서 '배포 패키지'로

스크립트가 어느 정도 안정되자, 저와 친하게 지내던 동료 기사 몇몇에게 공유하기 시작했습니다. 하지만 매번 그들의 폰을 받아서 복잡한 설정과 파일 복사를 해주는 것은 너무 번거로운 일이었습니다. 그래서 생각했죠.

> "버튼 하나만 누르면 자동으로 설치되게 만들자!"

이것이 바로 `f1m18yo/` 폴더에 있던 **자동 설치/제거 스크립트**의 탄생 배경입니다. 압축 파일을 풀고, 바로가기를 만들고, 레지스트리까지 수정해주는 모든 과정을 자동화했습니다. 제가 만든 스크립트가 제 손을 떠나 다른 사람의 폰에서 돌아가는 것을 보았을 때의 뿌듯함은 지금도 잊을 수 없습니다.

```mortscript
// --- 자동 설치 스크립트 (settinginnyo.mscr 예시) ---
If(DirExists("\My Storage"))
    // 압축 파일 풀기: f1m18yo.zip을 지정된 경로에 압축 해제
    UnzipAll("\My Storage\f1m18yo.zip", "Windows\Profiles\is")
    sleep(500)
    // 바로가기 생성: 메뉴 폴더와 시작 프로그램 폴더에 스크립트 바로가기 추가
    CreateShortcut("Windows\시작 메뉴\프로그램\firstnyo.lnk", "Windows\Profiles\is\firstnyo.mscr")
    CreateShortcut("Windows\시작 메뉴\프로그램\인성8칸전용.lnk", "Windows\Profiles\is\i8.mscr")
    // 설치 후 불필요한 파일 삭제 (정리)
    Delete("\My Storage\f1m18yo.zip")
    DelTree("\My Storage\f1m18yo")
EndIf

// --- 자동 제거 스크립트 (unsettingn.mscr 예시) ---
// 생성했던 바로가기들 삭제
Delete("Windows\시작 메뉴\프로그램\firstnyo.lnk")
Delete("Windows\시작 메뉴\프로그램\인성8칸전용.lnk")
// 설치된 스크립트 파일이 있는 폴더 삭제
DelTree("Windows\Profiles\is")
```

나중에는 수십 가지의 필터링 조합을 일일이 실행하기 귀찮아서, `il63선택.mscr` 파일처럼 **실행 시 메뉴를 띄워 원하는 옵션을 선택**하게 하는 수준까지 발전시켰습니다.

```mortscript
// --- 선택 메뉴 스크립트 (il63선택.mscr 예시) ---
Choice("인성6+로지3","원하는 배차 필터를 선택하세요", // 팝업창 제목과 설명
       "1. 인성6칸 로지3칸 일반 배차",
       "2. 인성6 2,3만 3칸 수원화성안산",
       "3. 인성6 3,4만 3칸 서울경기",
       // ... (나머지 16개 옵션)
       "20. 모든 스크립트 종료"
      )

Case(1) // 1번 옵션 선택 시
    // 해당 조건에 맞는 메인 스크립트 실행
    Run("\My Storage\Kone\il63a.mscr")
Case(2) // 2번 옵션 선택 시
    // 다른 조건에 맞는 메인 스크립트 실행
    Run("\My Storage\Kone\il63b.mscr")
// ... (Case 3부터 Case 19까지 유사한 로직)
Case(20) // 20번 옵션 선택 시 (모든 스크립트 종료)
    Run("\My Storage\Kone\ilout.mscr")
Case(0) // 팝업창에서 '취소' 버튼 선택 시
    Message("취소되었습니다.")
    Exit
EndChoice
```

### 과거의 유물을 추억하며

물론, 화면을 분석하는 저의 스크립트는 데이터를 직접 가로채는 '패킷 지지기'가 등장하면서 역사의 뒤안길로 사라졌습니다. 기술의 흐름 앞에 개인의 노력은 무력했죠. 저 또한 '퀵라이더 연대' 지지기로 갈아탈 수밖에 없었습니다.

하지만 옴니아 폰을 붙잡고 밤새 씨름했던 그 시절의 경험은 저에게 무엇과도 바꿀 수 없는 자산이 되었습니다. 덕분에 지금도 안드로이드에서 '자동화 앱' 같은 툴을 자유자재로 활용할 수 있게 되었고, 플랫폼의 정책이 어떻게 바뀌든 그 원리를 파악하고 새로운 생존 전략을 찾아낼 수 있는 '문제 해결 능력'을 갖게 되었으니까요.

이제는 추억이 된 윈도우 모바일과 모트스크립트. 비록 과거의 유물이지만, 제게는 가장 치열했던 시절의 훈장이자, 오늘의 저를 있게 한 고마운 스승이었습니다.
